/**
 * Security System Integration Hub
 * 
 * This file provides unified access to all security components
 * and serves as the main configuration point for the security system.
 * 
 * IMPORTANT: This module uses dynamic imports to prevent Next.js build errors.
 */

// Client-side security (always safe to import)
export { 
  getClientSecurity, 
  initializeClientSecurity,
  ClientSecurityMonitor 
} from './client-security'

// Security bridge (safe for both client and server)
export { 
  securityBridge, 
  secureConsoleLog, 
  sanitizeForTransmission,
  isClientSide,
  isServerSide 
} from './security-bridge'

// Types (safe to export)
export type { SecurityConfig } from './api-middleware'
export type { AuthContext, LoginResult, SessionValidationResult } from './secure-auth'
export type { RateLimitResult, RateLimitConfig } from './rateLimiter'

// Security configuration
export const SECURITY_CONFIG = {
  // Global security settings
  global: {
    environment: process.env.NODE_ENV || 'development',
    enableSecurityHeaders: true,
    enableAuditLogging: true,
    enableRealTimeMonitoring: true,
    maxRequestSize: 10 * 1024 * 1024, // 10MB
    defaultRateLimit: 'api:general',
    csrfProtection: true
  },

  // Authentication settings
  auth: {
    sessionTimeout: 24 * 60 * 60 * 1000, // 24 hours
    refreshThreshold: 4 * 60 * 60 * 1000, // 4 hours
    maxConcurrentSessions: 5,
    requireMFA: false, // Can be enabled per user
    passwordComplexity: true,
    accountLockout: {
      enabled: true,
      maxAttempts: 5,
      lockoutDuration: 30 * 60 * 1000 // 30 minutes
    }
  },

  // Rate limiting defaults
  rateLimiting: {
    enabled: true,
    defaultLimits: {
      api: { requests: 100, window: '1m', blockDuration: '10m' },
      auth: { requests: 5, window: '15m', blockDuration: '1h' },
      upload: { requests: 10, window: '1m', blockDuration: '5m' }
    }
  },

  // Database security
  database: {
    enforceRLS: true,
    auditQueries: true,
    maskSensitiveData: true,
    maxRecordsPerQuery: 1000,
    preventBulkOperations: false
  },

  // Monitoring thresholds
  monitoring: {
    alertThresholds: {
      failedLogins: 10,
      rateLimitViolations: 50,
      suspiciousActivity: 20,
      dataAccessViolations: 5
    },
    incidentAutoResponse: true,
    realTimeAlerts: true
  }
}

/**
 * Safe server module import helper
 */
async function safeImport<T>(modulePath: string): Promise<T | null> {
  if (typeof window !== 'undefined') {
    return null // Client-side, don't import server modules
  }
  
  try {
    return await import(modulePath)
  } catch (error) {
    console.error(`Failed to import server module: ${modulePath}`, error)
    return null
  }
}

/**
 * Initialize security system (context-aware)
 * Call this during application startup
 */
export async function initializeSecurity(): Promise<void> {
  const isClient = typeof window !== 'undefined'
  
  if (isClient) {
    // Client-side initialization
    const { initializeClientSecurity } = await import('./client-security')
    initializeClientSecurity({
      devToolsProtection: process.env.NODE_ENV === 'production',
      consoleOverride: process.env.NODE_ENV === 'production',
      debuggerProtection: process.env.NODE_ENV === 'production'
    })
    
    console.log('üõ°Ô∏è Client Security initialized')
  } else {
    // Server-side initialization
    const serverModules = await Promise.all([
      safeImport('./secure-logger'),
      safeImport('./security-monitor')
    ])
    
    const loggerModule = serverModules[0] as any
    const monitorModule = serverModules[1] as any
    
    if (loggerModule && monitorModule) {
      const { secureLogger, SecurityEventType } = loggerModule
      const { securityMonitor } = monitorModule
      
      console.log('üõ°Ô∏è Initializing AiEduLog Security System...')
      
      // Log security configuration (without sensitive details)
      secureLogger.info('Security system initialized', {
        environment: SECURITY_CONFIG.global.environment,
        features: {
          auditLogging: SECURITY_CONFIG.global.enableAuditLogging,
          realTimeMonitoring: SECURITY_CONFIG.global.enableRealTimeMonitoring,
          rateLimiting: SECURITY_CONFIG.rateLimiting.enabled,
          csrfProtection: SECURITY_CONFIG.global.csrfProtection
        }
      })

      // Initialize security monitor
      securityMonitor.recordSecurityEvent(SecurityEventType.SUSPICIOUS_ACTIVITY, {
        ipAddress: 'system',
        userAgent: 'security-init'
      }, {
        type: 'system_startup',
        message: 'Security system initialized successfully'
      })

      console.log('‚úÖ Security system ready')
    } else {
      console.error('Failed to initialize server security modules')
    }
  }
}

/**
 * Quick security health check (context-aware)
 */
export async function getSecurityHealth(): Promise<{
  status: 'healthy' | 'warning' | 'critical'
  components: Record<string, boolean>
  metrics: any
  lastCheck: string
}> {
  if (typeof window !== 'undefined') {
    // Client-side: Get status from bridge
    const { securityBridge } = await import('./security-bridge')
    const status = await securityBridge.getSecurityStatus()
    
    if (!status) {
      return {
        status: 'critical',
        components: { client: false },
        metrics: {},
        lastCheck: new Date().toISOString()
      }
    }
    
    return {
      status: status.healthy ? 'healthy' : 'critical',
      components: {
        client: status.healthy,
        ...status.clientProtections,
        ...status.serverProtections
      },
      metrics: status.violations,
      lastCheck: status.lastCheck
    }
  } else {
    // Server-side: Get detailed health check
    const serverModules = await Promise.all([
      safeImport('./security-monitor'),
      safeImport('./rateLimiter'),
      safeImport('./secure-logger')
    ])
    
    const monitorModule = serverModules[0] as any
    const rateLimiterModule = serverModules[1] as any
    const loggerModule = serverModules[2] as any
    
    if (!monitorModule || !rateLimiterModule || !loggerModule) {
      return {
        status: 'critical',
        components: {
          logger: false,
          rateLimiter: false,
          monitor: false,
          auth: false
        },
        metrics: {},
        lastCheck: new Date().toISOString()
      }
    }
    
    try {
      const { securityMonitor } = monitorModule
      const { rateLimiter } = rateLimiterModule
      const { secureLogger } = loggerModule
      
      const metrics = securityMonitor.getSecurityMetrics()
      const rateLimiterStats = rateLimiter.getStats?.() || { bufferSize: 0, throttleEntries: 0 }
      const loggerStats = secureLogger.getStats()

      // Component health checks
      const components = {
        logger: loggerStats.bufferSize < 1000,
        rateLimiter: rateLimiterStats.throttleEntries < 10000,
        monitor: metrics.activeThreats < 5,
        auth: true // TODO: Add auth health check
      }

      // Determine overall status
      let status: 'healthy' | 'warning' | 'critical' = 'healthy'
      
      if (metrics.activeThreats >= 5 || !components.logger) {
        status = 'critical'
      } else if (metrics.suspiciousActivities > 100 || rateLimiterStats.throttleEntries > 5000) {
        status = 'warning'
      }

      return {
        status,
        components,
        metrics: {
          ...metrics,
          rateLimiter: rateLimiterStats,
          logger: loggerStats
        },
        lastCheck: new Date().toISOString()
      }

    } catch (error) {
      const { secureConsoleLog } = await import('./security-bridge')
      secureConsoleLog('Security health check failed', error, 'error')
      
      return {
        status: 'critical',
        components: {
          logger: false,
          rateLimiter: false,
          monitor: false,
          auth: false
        },
        metrics: {},
        lastCheck: new Date().toISOString()
      }
    }
  }
}

/**
 * Emergency security lockdown (context-aware)
 * Use only in case of active security breach
 */
export async function emergencyLockdown(reason: string, duration: number = 3600000): Promise<void> {
  const isClient = typeof window !== 'undefined'
  
  if (isClient) {
    // Client-side: Report to server
    const { securityBridge } = await import('./security-bridge')
    securityBridge.reportSecurityEvent({
      type: 'client_violation',
      severity: 'CRITICAL',
      details: {
        action: 'emergency_lockdown',
        reason,
        duration
      },
      metadata: {
        userAgent: navigator.userAgent,
        url: window.location.href
      }
    })
    
    console.error('üö® CLIENT SECURITY LOCKDOWN ACTIVATED:', reason)
  } else {
    // Server-side: Full lockdown
    const serverModules = await Promise.all([
      safeImport('./secure-logger'),
      safeImport('./security-bridge')
    ])
    
    const loggerModule = serverModules[0] as any
    const bridgeModule = serverModules[1] as any
    
    if (loggerModule) {
      const { secureLogger, SecurityEventType } = loggerModule
      
      secureLogger.logSecurityEvent(SecurityEventType.SUSPICIOUS_ACTIVITY, {
        severity: 'CRITICAL',
        context: {
          action: 'emergency_lockdown',
          reason,
          duration,
          timestamp: Date.now()
        }
      })
    }

    if (bridgeModule) {
      const { secureConsoleLog } = bridgeModule
      secureConsoleLog('üö® EMERGENCY SECURITY LOCKDOWN ACTIVATED: ' + reason, undefined, 'error')
    } else {
      console.error('üö® EMERGENCY SECURITY LOCKDOWN ACTIVATED:', reason)
    }
  }
}

/**
 * Get security dashboard data (server-side only)
 */
export async function getSecurityDashboard(): Promise<{
  overview: any
  recentIncidents: any[]
  threatIntelligence: any[]
  metrics: any
  alerts: any[]
} | null> {
  if (typeof window !== 'undefined') {
    // Client-side: Cannot access full dashboard, return null
    return null
  }
  
  const monitorModule = await safeImport('./security-monitor')
  if (!monitorModule) {
    return null
  }
  
  try {
    const { securityMonitor } = monitorModule as any
    
    const metrics = securityMonitor.getSecurityMetrics()
    const incidents = securityMonitor.getActiveIncidents()
    const threatIntel = securityMonitor.getThreatIntelligence()
    const health = await getSecurityHealth()

    return {
      overview: {
        status: health.status,
        totalRequests: metrics.totalRequests,
        blockedRequests: metrics.blockedRequests,
        activeThreats: metrics.activeThreats,
        lastUpdated: metrics.lastUpdated
      },
      recentIncidents: incidents.slice(0, 10), // Last 10 incidents
      threatIntelligence: threatIntel.slice(0, 20), // Top 20 threats
      metrics,
      alerts: incidents
        .filter((incident: any) => incident.escalated)
        .slice(0, 5) // Top 5 escalated alerts
    }
  } catch (error) {
    return null
  }
}

/**
 * Validate security configuration
 */
export function validateSecurityConfig(): { valid: boolean; errors: string[]; warnings: string[] } {
  const errors: string[] = []
  const warnings: string[] = []

  // Check environment variables
  if (!process.env.NEXT_PUBLIC_SUPABASE_URL) {
    errors.push('Missing NEXT_PUBLIC_SUPABASE_URL')
  }
  
  if (!process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY) {
    errors.push('Missing NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY')
  }

  // Check production readiness
  if (process.env.NODE_ENV === 'production') {
    if (SECURITY_CONFIG.auth.requireMFA === false) {
      warnings.push('MFA not required in production')
    }
    
    if (!SECURITY_CONFIG.monitoring.realTimeAlerts) {
      warnings.push('Real-time alerts disabled in production')
    }
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings
  }
}

// Server-only exports using dynamic imports
export async function getSecureLogger() {
  const loggerModule = await safeImport('./secure-logger')
  return loggerModule ? (loggerModule as any).secureLogger : null
}

export async function getRateLimiter() {
  const rateLimiterModule = await safeImport('./rateLimiter')
  return rateLimiterModule ? (rateLimiterModule as any).rateLimiter : null
}

export async function getSecurityMonitor() {
  const monitorModule = await safeImport('./security-monitor')
  return monitorModule ? (monitorModule as any).securityMonitor : null
}

export async function getSecureAuthService() {
  const authModule = await safeImport('./secure-auth')
  return authModule ? (authModule as any).secureAuthService : null
}

export async function getSecureDatabase() {
  const dbModule = await safeImport('./secure-database')
  return dbModule ? dbModule : null
}

export async function getApiMiddleware() {
  const middlewareModule = await safeImport('./api-middleware')
  return middlewareModule ? middlewareModule : null
}

// Default export for convenience
export default {
  initialize: initializeSecurity,
  health: getSecurityHealth,
  dashboard: getSecurityDashboard,
  validate: validateSecurityConfig,
  emergencyLockdown,
  config: SECURITY_CONFIG,
  // Dynamic getters
  getSecureLogger,
  getRateLimiter,
  getSecurityMonitor,
  getSecureAuthService,
  getSecureDatabase,
  getApiMiddleware
}